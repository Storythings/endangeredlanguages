<!DOCTYPE html>
<meta charset="utf-8">
<title>Dorling Cartogram</title>
<style>
    h1 {
        text-align: center
    }
    
    circle {
        fill: #eee;
        stroke: #000;
        stroke-width: 0.5px;
    }
    
    .d3-tip {
        line-height: 1.5;
        font-weight: normal;
        padding: 12px;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        border-radius: 2px;
        pointer-events: none;
        max-width: 300px;
    }
    
    .d3-tip:after {
        box-sizing: border-box;
        display: inline;
        font-size: 10px;
        width: 100%;
        line-height: 1;
        color: rgba(0, 0, 0, 0.8);
        content: "\25BC";
        position: absolute;
        pointer-events: none;
    }

</style>

<body>
    <script src="//d3js.org/d3.v3.min.js"></script>
    <script src="//d3js.org/topojson.v1.min.js"></script>
    <script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>

    <h1>Endangered Languages</h1>

    <script>
        var w = window,
            d = document,
            e = d.documentElement,
            g = d.getElementsByTagName('body')[0],
            theWidth = w.innerWidth || e.clientWidth || g.clientWidth,
            theHeight = w.innerHeight || e.clientHeight || g.clientHeight;

        var margin = {
                top: -150,
                right: 0,
                bottom: 0,
                left: 0
            },
            width = theWidth - margin.left - margin.right,
            height = theHeight - margin.top - margin.bottom,
            padding = 0;

        var projection = d3.geo.equirectangular()
            .scale(width / 6.5)
            .translate([width / 2, height / 2]);

        var radius = d3.scale.sqrt()
            .domain([0, 7500000])
            .range([width / 700, width / 100]);

        var force = d3.layout.force()
            .charge(0)
            .gravity(0)
            .size([width, height]);

        var svg = d3.select("body").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        var path = d3.geo.path()
            .projection(projection);

        var tip = d3.tip()
            .attr('class', 'd3-tip')
            .offset([-10, 0])
            .html(function(d) {
                return "<strong>" + d.name + " - <span style='color:" + d.warningCol + "'>" + d.cat + "</span></strong><br> <span style='color:white'>" + d.descrip + "</span>";
            })

        svg.call(tip);

        // Add MAP OF THE WORLD
        d3.json("world-50m.json", function(error, world) {
            if (error) throw error;

            var countries = topojson.feature(world, world.objects.countries).features,
                neighbors = topojson.neighbors(world.objects.countries.geometries);

            svg.selectAll(".country")
                .data(countries)
                .enter().insert("path", ".graticule")
                .attr("class", "country")
                .attr("d", path)
                .style("fill", "#00000008");

        });

        // LOAD THE REST
        d3.json("extinct_languages.json", function(error, langs) {
            if (error) throw error;

            var nodes = langs.features
                .filter(function(d) {
                    return !isNaN(d["Number of speakers"]);
                })
                .map(function(d) {
                    var point = projection([d.Longitude, d.Latitude]),
                        value = +d["Number of speakers"],
                        name = d["Name in English"],
                        descrip = d["Description of the location"],
                        cat = d["Degree of endangerment"],
                        warningCol = "green";
                    if (isNaN(value)) fail();
                    switch (cat) {
                        case "Vulnerable":
                            warningCol = "yellow";
                            break;

                        case "Definitely endangered":
                            warningCol = "orange";
                            break;

                        case "Severely endangered":
                            warningCol = "red";
                            break;

                        case "Critically endangered":
                            warningCol = "purple";
                            break;

                        case "Extinct":
                            warningCol = "white";
                            break;

                        default:
                            warningCol = "blue";
                            break;
                    }

                    return {
                        x: point[0],
                        y: point[1],
                        x0: point[0],
                        y0: point[1],
                        r: radius(value),
                        value: value,
                        name: name,
                        descrip: descrip,
                        cat: cat,
                        warningCol: warningCol
                    };
                });

            force
                .nodes(nodes)
                .on("tick", tick)
                .start();

            var node = svg.selectAll("circle")
                .data(nodes)
                .enter().append("circle")
                .attr("r", function(d) {
                    return d.r;
                })
                .style("fill", function(d) {
                    switch (d.cat) {
                        case "Vulnerable":
                            return "yellow";
                            break;

                        case "Definitely endangered":
                            return "orange";
                            break;

                        case "Severely endangered":
                            return "red";
                            break;
                            
                        case "Critically endangered":
                            return "purple";
                            break;
                            
                        case "Extinct":
                            return "none";
                            break;
                            
                        default:
                            return "blue";
                            break;
                    }
                })
                .on('mouseover', tip.show)
                .on('mouseout', tip.hide);

            function tick(e) {
                node.each(gravity(e.alpha * .1))
                    .each(collide(.5))
                    .attr("cx", function(d) {
                        return d.x;
                    })
                    .attr("cy", function(d) {
                        return d.y;
                    });
            }

            function gravity(k) {
                return function(d) {
                    d.x += (d.x0 - d.x) * k;
                    d.y += (d.y0 - d.y) * k;
                };
            }

            function collide(k) {
                var q = d3.geom.quadtree(nodes);
                return function(node) {
                    var nr = node.r + padding,
                        nx1 = node.x - nr,
                        nx2 = node.x + nr,
                        ny1 = node.y - nr,
                        ny2 = node.y + nr;
                    q.visit(function(quad, x1, y1, x2, y2) {
                        if (quad.point && (quad.point !== node)) {
                            var x = node.x - quad.point.x,
                                y = node.y - quad.point.y,
                                l = x * x + y * y,
                                r = nr + quad.point.r;
                            if (l < r * r) {
                                l = ((l = Math.sqrt(l)) - r) / l * k;
                                node.x -= x *= l;
                                node.y -= y *= l;
                                quad.point.x += x;
                                quad.point.y += y;
                            }
                        }
                        return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
                    });
                };
            }
        });

    </script>
